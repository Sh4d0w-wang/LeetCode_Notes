# 二进制求和

>   难度：简单

给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。

示例：

```
输入:a = "11", b = "1"
输出："100"

输入：a = "1010", b = "1011"
输出："10101"
```

### Solve

>   C:
>

```C
#define max(a, b) (a > b ? a : b)

char* addBinary(char *a, char *b){
    int a_len = strlen(a);
    int b_len = strlen(b);
    // 需要一个额外的位置保存'\0'，需要一个额外的位置保存可能的最高位进位
    int ans_len = max(a_len, b_len) + 1 + 1;

    char *ans = malloc(sizeof(char) * ans_len);
    ans[0] = '0';   // 默认两数相加没有最高位进位
    ans[ans_len - 1] = '\0';

    int cf = 0;      // 进位
    int i = a_len - 1, j = b_len - 1, k = ans_len - 2;      // 从末尾开始各个位相加
    while (i >= 0 || j >= 0) {
        int a_bit = i >= 0 ? a[i] - '0' : 0;
        // a中还有数的情况下
        // 取前者--> '1' - '0' = 1; '0' - '0' = 0
        int b_bit = j >= 0 ? b[j] - '0' : 0;
        int bit_sum = a_bit + b_bit + cf;

        ans[k] = '0' + bit_sum % 2;

        cf = bit_sum / 2;
        --i;--j;--k;
    }
    if (cf != 0)
        ans[k] = '1';
    return ans[0] == '0' ? ans + 1 : ans;
}
```

>   Python:
>

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        a_int = int(a, 2)
        b_int = int(b, 2)
        return bin(a_int + b_int)[2::]
```



