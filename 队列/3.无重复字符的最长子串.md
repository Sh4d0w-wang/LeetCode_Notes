### 3.无重复字符的最长子串

题目链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/

#### 暴力解

时间复杂度
$$
O(n^{2})
$$

```C
/*
 * 定义了一个i(左边)和j(右边)，暴力从头开始扫,[定右边，扫左边是否有一样的]
 * a  b  c  d  e  f  a
 * i                 j(i在不停的扫，看有没有和j一样的)
 * 一样就说明了子串长度是"尾 - 首 + 1";
 * 之后再对比长度谁大谁小
*/
int lengthOfLongestSubstring(char* s) {
    int len = strlen(s);
    // 长度为0,直接返回0
    if(len == 0){
        return 0;
    }
    // 之后无论给出什么字符串，最低都是1
    int max_len = 1;
    // left表示子串的最左边在哪
    int left = 0, i = 0, j = 0;
    for(j = 1; j < len; j++){
        for(i = left; i < j; i++){
            if(s[j] == s[i]){
                left = i + 1;
                break;
            }
        }
        // 也可以max_len = (j - left + 1) < max_len ? max_len : (j - left + 1);
        if((j - left + 1) > max_len){
            max_len = j - left + 1;
        }
    }
    return max_len;
}
/*
 * 总结：
 * 一开始写的搞反了，是定左边扫右边，导致一些特殊的输入不能正常输出,比如"dvdf"
*/
```





